/**
 **************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 **************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 **************************
 */

#include <stdint.h>

typedef struct{
volatile uint32_t MODER;
volatile uint32_t OTYPER;
volatile uint32_t OSPEEDR;
volatile uint32_t PUPDR;
volatile uint32_t IDR;
volatile uint32_t ODR;
volatile uint32_t BSRR;
volatile uint32_t LCKR;
volatile uint32_t AFRL;
volatile uint32_t AFRH;
} GPIO;

typedef struct{
volatile uint32_t CR1;
volatile uint32_t CR2;
volatile uint32_t SMCR;
volatile uint32_t DIER;
volatile uint32_t SR;
volatile uint32_t EGR;
volatile uint32_t CCMR1;
volatile uint32_t CCMR2;
volatile uint32_t CCER;
volatile uint32_t CNT;
volatile uint32_t PSC;
volatile uint32_t ARR;
uint32_t reserved;
volatile uint32_t CCR1;
volatile uint32_t CCR2;
volatile uint32_t CCR3;
} TIM;


#define RCC_AHB2ENR *((volatile uint32_t *) (0x40021000 + 0x4C))
#define RCC_APB1ENR1 *((volatile uint32_t *) (0x40021000 + 0x58))
#define GPIOB ((GPIO *) 0x42020400)
#define TIM2 ((TIM *) 0x40000000)
#define TIM3 ((TIM *) 0x40000400)


void init_timer() {

    RCC_APB1ENR1 |= 0x01;        // Turn on Timer2
    RCC_APB1ENR1 |= 0x01 << 1;	 // Turn on Timer3

    GPIOB->AFRH &= ~(0x0F << ((10 - 8) * 4)); // AFRH reset
    GPIOB->AFRH |= (0x01 << ((10 - 8) * 4)); // AF1(TIM2_CH3) selection for PB10

    TIM2->PSC = 110 - 1;		// Reduce 110 MHz system frequency to 1 MHz
    TIM2->ARR = 200 - 1;		// Set 20 ms period (50 Hz)

    TIM3->PSC = 110 - 1;	// Reduce 110 MHz system frequency to 1 MHz
    TIM3->ARR = 2000 - 1;	// Set 200 ms period (5 Hz)


    TIM2->CCMR2 &= ~(0x07 << 4);      // CCMR2 Clear bits
    TIM2->CCMR2 |= (0x06 << 4);       // PWM mode 1 selection for CH3
    TIM2->CCER |= (0x01 << 8);           // Enable CH3 output

    TIM2->CR1 |= 0x01; // Start timer2
    TIM3->CR1 |= 0x01;	// Start timer3
}
// Basic delay function
void delay(volatile unsigned int s)
{
    while (s--);
}

int main(void)
{

	// Turn on the GPIOB port.
	RCC_AHB2ENR |= 0x02;

    GPIOB->MODER &= ~(0x03 << (10 * 2));   	// PB10 clear bits
    GPIOB->MODER |= (0x02 << (10 * 2));    	// Set PB10 as alternate function

	init_timer();

	GPIOB->MODER &= ~(0x03 <<(11 * 2));		// PB11 as input mode

	GPIOB->MODER &= ~(0x03 <<(9 * 2));		// PB9 as input mode

	GPIOB->MODER &= ~(0x03 <<(8 * 2));		// PB8 clear bits
	GPIOB->MODER |= (0x01 << (8 * 2));		// PB8 as output mode

	GPIOB->MODER &= ~(0x03 <<(6 * 2));		// PB6 clear bits
	GPIOB->MODER |= (0x01 << (6 * 2));		// PB6 as output mode

	GPIOB->ODR |= (0x01 << 6);				// PB6 as high voltage


	while(1)
	{

		if ((GPIOB->IDR & (0x01 << 11)) == 0x01 << 11)
		{
			if ((GPIOB->IDR & (0x01 << 9)) == 0)
			{
				TIM2->CCR3 = 20; //2ms %10 duty cycle (fast rotate left)
				delay(350000);
				TIM2->CCR3 = 10; // 1ms %5 duty cycle (neutral)
				delay(500000);
				TIM2->CCR3 = 40; // 4ms %20 duty cycle (slow rotate left)
				delay(800000);
				GPIOB->ODR &= ~(0x01 << 8); // PB8 as low voltage
			}
			else
			{
				TIM2->CCR3 = 10; // 1ms %5 duty cycle (neutral)
				volatile unsigned int delay = 5;
				while (delay > 0)
				{
					GPIOB->ODR |= (0x01 << 8); // PB8 as high voltage
					TIM3->CNT = 0;
					while ((TIM3->SR & 1) == 0); // Timer3 in action
					TIM3->SR = 0;

					GPIOB->ODR &= ~(0x01 << 8);	// PB8 as low voltage
					TIM3->CNT = 0;
					while ((TIM3->SR & 1) == 0); // Timer3 in action
					TIM3->SR = 0;

					delay--;
				}


			}


		}

		else
		{

			GPIOB->ODR &= ~(0x01 << 8); // PB8 as low voltage
			TIM2->CCR3 = 10; // 1ms %5 duty cycle (neutral)
		}



	}
}
